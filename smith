#!/bin/bash

GREEN='\033[0;32m'
END='\033[0m'

# Search through the out/ directory.
search() {
	results=$(grep -rliE "$1" out)
	if [[ -n "$results" ]]; then
		while read -r url; do
			head -1 "$url";
		done <<< "$results"
		echo
	fi
}

spit() {
	echo -e "${GREEN}==> $1 <==${END}"
}

# This function handles all the files to look for
# in the out/ directory.
files() {
	spit "Webalizer instances"
	search "webalizer"

	spit "GitLab instances"
	search "Explore GitLab"

	spit "Phppgadmin instances"
	search "phppgadmin:"

	spit "htaccess files"
	search "RewriteEngine"

	spit "Gitea instances"
	search "Gitea Version:"

	spit "phpinfo() pages"
	search "PHP Version"

	spit "Public ssh keys"
	search "ssh-rsa"

	spit "Apache Server Status files"
	search "Apache Server Status for"

	spit "Perl CGI environment variables"
	search "GATEWAY_INTERFACE=\"CGI"

	spit "Prometheus instances"
	search "machine{name"

	spit "GIT configuration files"
	search "\[remote \"origin\"\]"

	spit "Wordpress configuration files"
	search "define\('WP_HOME"

	spit "Jenkins instances"
	search "stage\('Build'\)"

	spit "Gemfiles"
	search "gem '"

	spit "Gemfile.lock files"
	search "BUNDLED WITH"

	spit "PhpMyAdmin instances"
	search "Welcome to phpmyadmin"
}

crlf() {
	spit "CRLF injection vulnerabilities"
	search "< Set-Cookie: ?crlf"
}

openredirects() {
	spit "Open redirect vulnerabilities"
	search '< location: (https?:)?[/\\]{2,}example.com'
}

# This functions looks for actual security vulnerabilities.
vulnerabilities() {
	crlf
	openredirects
}

error() {
	echo """
Simple wrapper for meg that sieves through meg's output for you.

Usage:
	smith <host>
	    smith http://example.com

	smith <list of hosts>
	    smith list.txt

	smith <host or list of hosts> -s <scan type>
		smith http://example.com -s crlf
		smith http://example.com -s openredirects
		smith http://example.com -s files

	smith search <type>
		smith search crlf

	All types:
		- crlf
		- openredirects
		- files

Word lists:
	All word lists are located under the lists/ directory.

	- crlf.txt
	- openredirects.txt
	- wordlist.txt
	"""
	exit 1
}

# This sort of acts as the main() function.
if [[ $1 == "" ]] || [[ $1 == "-h" ]] || [[ $1 == "--help" ]]; then
	error
elif [[ $1 == "search" ]]; then
	if [[ $2 == "crlf" ]]; then
		crlf
	elif [[ $2 == "openredirects" ]]; then
		openredirects
	elif [[ $2 == "files" ]]; then
		files
	else
		error
	fi
elif [[ $2 == "-s" ]]; then
	if [[ $3 == "crlf" ]]; then
		# Use the rawhttp library for CRLF injection.
		meg -d 100 -c 200 -r lists/crlf.txt "$1" 2> /dev/null
		crlf
	elif [[ $3 == "openredirects" ]]; then
		# Use Go HTTP client for the open redirects list.
		meg -d 100 -c 200 lists/openredirects.txt "$1" 2> /dev/null
		openredirects
	elif [[ $3 == "files" ]]; then
		# Use Go HTTP client for main word list.
		meg -d 100 -c 200 lists/wordlist.txt "$1" 2> /dev/null
		# Only scan for files.
		files
	else
		error
	fi
else
	read -p "Running a full scan can be quite slow. \
Are you sure you want to proceed? (y/n) " -n 1 -r
	echo
	if [[ $REPLY =~ ^[Yy]$ ]]; then
		# Use Go HTTP client for main word list.
		meg -d 100 -c 200 lists/wordlist.txt "$1" 2> /dev/null
		# Use Go HTTP client for the open redirects list.
		meg -d 100 -c 200 lists/openredirects.txt "$1" 2> /dev/null
		# Use the rawhttp library for CRLF injection.
		meg -d 100 -c 200 -r lists/crlf.txt "$1" 2> /dev/null
		# If no flag is specified, just perform a general
		# scan with all available options.
		files
		vulnerabilities
	else
		exit 1
	fi
fi
